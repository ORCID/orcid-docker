ssl_dhparam          /etc/nginx/dhparam.pem;
ssl_certificate      /etc/nginx/ssl.crt;
ssl_certificate_key  /etc/nginx/ssl.key;
ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4";
ssl_prefer_server_ciphers on;
ssl_session_cache shared:SSL:10m;  

server {
    listen 80 default_server;
    listen 443 default_server ssl;
    listen [::]:80 ipv6only=on;
    listen [::]:443 ipv6only=on;

    server_name dev.orcid.org;

    gzip on;
    gzip_comp_level 9;
    gzip_types *;
    gzip_proxied any;

    access_log  off;
    keepalive_timeout 300s;
    client_max_body_size 50m;
    length_hiding on;

    set $do_https_rewrite "T";    # should we redir to https
    set $isHttps "F"; # asking for https
    set $isId "F";  # is it an orcid id uri
    set $isMeta "F"; # is it json or xml request
    set $isAllowedHttp "F"; # is index page
    set $isApiSearch "F"; # is api search
    set $isPubApi "F"; # is the public API
    set $isMemberApi "F"; # is the memeber API
    
    if ($scheme = https) {
        set $do_https_rewrite "F";
        set $isHttps "T";
    }

    if ($http_x_forwarded_proto = https) {
        set $do_https_rewrite "F";
        set $isHttps "T";
    }

    ########################################
    # start static files
    ########################################

    location = /favicon.ico  {
        proxy_cache_valid  200 302  7d;
        proxy_cache_valid  404      1m;
        proxy_read_timeout 120;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_set_header Host $http_host;
        proxy_pass http://REGISTRY_IP_PORT/orcid-web/static/img/favicon.ico;
        expires 30d;
    }

    location /static/  {
        proxy_cache_valid  200 302  7d;
        proxy_cache_valid  404      1m;
        proxy_read_timeout 120;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;
        proxy_pass http://REGISTRY_IP_PORT/orcid-web/static/;
        expires 30d;
    }

    ########################################
    # end static files
    ########################################
    

    ########################################
    # start shibboleth
    ########################################
    
    #FastCGI authorizer for Auth Request module
    location = /shibauthorizer {
        internal;
        include fastcgi_params;
        fastcgi_pass unix:/opt/shibboleth-sp/shibauthorizer.sock;
    }

    #FastCGI responder
    location /Shibboleth.sso {
        fastcgi_param SERVER_PORT 443;
        include fastcgi_params;
        fastcgi_pass unix:/opt/shibboleth-sp/shibresponder.sock;

        location /Shibboleth.sso/DiscoFeed {
            expires 1h;
            gzip on;
            gzip_comp_level 9;
            gzip_types application/json;
            gzip_proxied any;
            fastcgi_cache shib_zone;
            fastcgi_cache_valid 200 60m;
            fastcgi_param SERVER_PORT 443;
            include fastcgi_params;
            fastcgi_pass unix:/opt/shibboleth-sp/shibresponder.sock;
        }
    }

    #Resources for the Shibboleth error pages. This can be customised.
    location /shibboleth-sp {
        alias /usr/share/shibboleth/;
    }

    #A secured location.  Here all incoming requests query the
    #FastCGI authorizer.  Watch out for performance issues and spoofing.
    location /secure {
        #Add your attributes here. They get introduced as headers
        #by the FastCGI authorizer so we must prevent spoofing.
        more_clear_input_headers 'Affiliation' 'Entitlement' 'Shib-Application-Id' 'Shib-Authentication-Instant' 'Shib-Authentication-Method' 'Shib-Authncontext-Class' 'Shib-Identity-Provider' 'Shib-Session-Id' 'Shib-Session-Index' 'Unscoped-Affiliation' 'Remote-User' 'REMOTE_USER' 'Auth-Type' 'AUTH_TYPE' 'eppn' 'persistent-id' 'targeted-id' 'targeted-id-oid' 'edu-person-unique-id' 'sn' 'givenName' 'displayName' 'mail';
        shib_request /shibauthorizer;
        shib_request_use_headers on;
        proxy_pass http://httpbin.org/get;
    }

    #A secured location.  Here all incoming requests query the
    #FastCGI authorizer.  Watch out for performance issues and spoofing.
    location /shibboleth {
        if ($do_https_rewrite = "T") {
            return 301 https://$server_name$request_uri;
        }
        
        #Add your attributes here. They get introduced as headers
        #by the FastCGI authorizer so we must prevent spoofing.
        more_clear_input_headers 'Affiliation' 'Entitlement' 'Shib-Application-Id' 'Shib-Authentication-Instant' 'Shib-Authentication-Method' 'Shib-Authncontext-Class' 'Shib-Identity-Provider' 'Shib-Session-Id' 'Shib-Session-Index' 'Unscoped-Affiliation' 'Remote-User' 'REMOTE_USER' 'Auth-Type' 'AUTH_TYPE' 'eppn' 'persistent-id' 'targeted-id' 'targeted-id-oid' 'edu-person-unique-id' 'sn' 'givenName' 'displayName' 'mail';
        shib_request /shibauthorizer;
        shib_request_use_headers on;
        
        proxy_read_timeout 120;
        proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header    X-Real-IP       $remote_addr;
        set $proto 'http';
        if ($scheme = 'https') {
           set $proto 'https';
        }
        if ($http_x_forwarded_proto = 'https') {
           set $proto 'https';
        }
        proxy_set_header X-Forwarded-Proto $proto;
        proxy_set_header Host $http_host;

        # Tomcat has no trailing slash after the cookie path (by default) from version 8.0.37 onwards
        # Before 8.0.37
        proxy_cookie_path /orcid-web/ /;
        # From 8.0.37 onwards
        proxy_cookie_path /orcid-web /;

        proxy_pass http://REGISTRY_IP_PORT/orcid-web$request_uri;
        
        proxy_redirect http://$host/orcid-web/ http://$host/;
        proxy_redirect https://$host/orcid-web/ https://$host/; 
    }

    location /saml2/provider/ {
        root /opt/shibboleth-sp/share/published/;
    }

    location /echo {
        default_type text/plain;
        echo_duplicate 1 $echo_client_request_headers;
        echo "\r";
        echo_read_request_body;
        echo $request_body;
    }

    ########################################
    # end shibboleth
    ########################################


    # rewrite 000000000000 to 0000-0000-0000-0000
    if ($uri ~ ^/\d\d\d\d\d\d\d\d\d\d\d\d\d\d\d(\d|X)$) {
       rewrite ^/(\d\d\d\d)(\d\d\d\d)(\d\d\d\d)(\d\d\d(\d|X))$ http://$server_name/$1-$2-$3-$4 break;
    }

    if ($uri ~* "^/(tomcatUp|webStatus)\.json$") {
       set $do_https_rewrite "F";
    }
    
    if ($uri ~* "/pubStatus$") {
        set $isPubApi "T";
        set $do_https_rewrite "F";
    }
    
    if ($uri ~* "/apiStatus$") {
        set $isMemberApi "T";
        set $do_https_rewrite "F";
    }

    if ($uri ~* "^/public/.*$") {
       set $do_https_rewrite "F";
    }
	
    # if it's a public orcid id request
    if ( $uri ~ ^/(experimental_rdf_[^\/]*/)?\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d(\d|X).*$) {
        set $isId "T";
        set $do_https_rewrite "F";
    }

   # if it's a UI json request don't go to the pub api, even if contains orcid.
   if ( $uri ~* ".json($|\?.*$)") {
        set $isId "F";
    }

    if ( $http_accept ~ ^application/.*(xml|json|rdf) ) {
        set $isMeta "T";
    }

    if ( $uri ~ ^(|/v[0-9\.]+)/search/orcid-bio($|/.*$)) {
        set $isApiSearch "T";
    }

    if ( $http_accept ~ ^text/.*(n3|turtle) ) {
        set $isMeta "T";
    }

    # finally make sure is meta doesn't ignore */*
    # in which case we want to match html
    if ( $http_accept ~ \*/\* ) {
        set $isMeta "F";
    }

    location / {

        set $app_path "/orcid-web";
        set $isIdIsMetaIsHttps "${isId}${isMeta}";
        if ($isIdIsMetaIsHttps = "TT") {
            set $app_path "/orcid-pub-web";
        }

        if ($isPubApi = "T") {
            set $app_path "/orcid-pub-web";
        }
        
        if ($isMemberApi = "T") {
            set $app_path "/orcid-api-web";
        }
    
        # everything else is https
        if ($do_https_rewrite = "T") {
            return 301 https://$server_name$request_uri;
        }
        
        client_max_body_size 200m;
        limit_req   zone=web  burst=40;

        proxy_read_timeout 120;
        proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header    X-Real-IP       $remote_addr;
        set $proto 'http';
        if ($scheme = 'https') {
           set $proto 'https';
        }
        if ($http_x_forwarded_proto = 'https') {
           set $proto 'https';
        }
        proxy_set_header X-Forwarded-Proto $proto;
        
        proxy_set_header Host $http_host;

        # Tomcat has no trailing slash after the cookie path (by default) from version 8.0.37 onwards
        # Before 8.0.37
        proxy_cookie_path /orcid-web/ /;
        # From 8.0.37 onwards
        proxy_cookie_path /orcid-web /;

        # api searches go to public api
        if ( $isApiSearch = "T" ) {
           set $app_path "/orcid-pub-web";
        }
                
        set $proxHeader "${http_host}";   
        proxy_pass http://REGISTRY_IP_PORT$app_path$request_uri;
        
        proxy_redirect http://$host/orcid-web/ http://$host/;
        proxy_redirect https://$host/orcid-web/ https://$host/; 
        
    }

    location /oauth/signin {
        rewrite ^/oauth/signin(.*) https://$host/oauth/authorize permanent;
    }

    #redirect server error pages to the static page /50x.html
    error_page 500 503 504 /50x.html;
    location = /50x.html {
          root /usr/share/nginx/html;
    }

    error_page 404 /404.html;
    location = /404.html {
          root /usr/share/nginx/html;
    }

    # 502 we are assuming we are doing a release
    error_page 502 /maintenance.html;
    location = /maintenance.html {
          root /usr/share/nginx/html;
    }

}

